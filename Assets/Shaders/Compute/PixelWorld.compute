#pragma kernel CSInit
#pragma kernel CSMain

// Dimensions
uint _Width;
uint _Height;
float _Time;
uint _Seed;

// Mouse Input: x, y, radius, materialID
float4 _MouseInput;

// World State Buffers (RInt format expected)
RWTexture2D<int> WorldIn;
RWTexture2D<int> WorldOut;

// Material IDs
#define MAT_EMPTY 0
#define MAT_ROCK 1
#define MAT_DIRT 2
#define MAT_SAND 3
#define MAT_WATER 4

// Constants
#define WATER_SCAN_RADIUS 5

// -- Noise Helpers --
float hash(float2 p) {
    p = 50.0 * frac(p * 0.3183099 + float2(0.71, 0.113));
    return -1.0 + 2.0 * frac(p.x * p.y * (p.x + p.y));
}

float noise(float2 p) {
    float2 i = floor(p);
    float2 f = frac(p);
    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(lerp(hash(i + float2(0.0, 0.0)), hash(i + float2(1.0, 0.0)), u.x),
                lerp(hash(i + float2(0.0, 1.0)), hash(i + float2(1.0, 1.0)), u.x), u.y);
}

float fbm(float2 p) {
    float f = 0.0;
    f += 0.5000 * noise(p); p *= 2.02;
    f += 0.2500 * noise(p); p *= 2.03;
    f += 0.1250 * noise(p); p *= 2.01;
    return f;
}

[numthreads(8,8,1)]
void CSInit (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;

    float2 uv = float2(id.x, id.y) / float2(_Width, _Height);
    float2 offset = float2(_Seed * 12.34, _Seed * 56.78);
    
    // 1. Cave Noise
    float caveNoise = fbm((uv + offset) * float2(8.0, 16.0));
    
    // 2. Surface Terrain
    float surfaceHeight = 0.95 + 0.02 * noise((uv.x + offset.x) * 15.0 * float2(1, 0));
    
    // 3. Mineral Noise
    float mineralNoise = noise((uv + offset + float2(5.2, 1.3)) * 20.0);

    int mat = MAT_EMPTY;
    
    if (uv.y > surfaceHeight)
    {
        mat = MAT_EMPTY;
    }
    else
    {
        float caveThreshold = 0.35;
        if (uv.y < 0.5) caveThreshold = 0.32;
        
        if (caveNoise > caveThreshold)
        {
            if (uv.y < 0.3 && caveNoise > 0.6) mat = MAT_WATER;
            else mat = MAT_EMPTY;
        }
        else
        {
            float depth = surfaceHeight - uv.y;
            
            if (depth < 0.05) 
            {
                mat = MAT_DIRT; 
                if (mineralNoise > 0.6) mat = MAT_SAND;
            }
            else 
            {
                mat = MAT_ROCK;
                if (mineralNoise > 0.7) mat = MAT_SAND;
            }
        }
    }
    
    if (id.x < 5 || id.x > _Width - 5 || id.y < 5) mat = MAT_ROCK;

    WorldOut[id.xy] = mat;
}

// --- Physics Logic (Pull-based) ---

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _Width || id.y >= _Height) return;

    // 1. Apply Mouse Input
    if (_MouseInput.z > 0)
    {
        float dx = (float)id.x - _MouseInput.x;
        float dy = (float)id.y - _MouseInput.y;
        float distSq = dx*dx + dy*dy;
        float radSq = _MouseInput.z * _MouseInput.z;

        if (distSq < radSq)
        {
            if (_MouseInput.w == 0)
            {
                float noiseVal = noise(float2(id.x + _Time * 100.0, id.y) * 0.1);
                if (distSq < radSq * (0.8 + 0.2 * noiseVal))
                {
                    WorldOut[id.xy] = MAT_EMPTY;
                    return;
                }
            }
            else
            {
                WorldOut[id.xy] = (int)_MouseInput.w;
                return;
            }
        }
    }

    // 2. Simulation
    int self = WorldIn[id.xy];
    int up    = (id.y < _Height - 1) ? WorldIn[uint2(id.x, id.y + 1)] : MAT_EMPTY;
    int down  = (id.y > 0)           ? WorldIn[uint2(id.x, id.y - 1)] : MAT_ROCK;
    int left = (id.x > 0) ? WorldIn[uint2(id.x-1, id.y)] : MAT_ROCK;
    int right = (id.x < _Width-1) ? WorldIn[uint2(id.x+1, id.y)] : MAT_ROCK;
    
    int result = self;
    bool parity = ((id.x + id.y + (int)(_Time * 120.0)) % 2 == 0);

    if (self == MAT_SAND)
    {
        if (down == MAT_EMPTY || down == MAT_WATER)
        {
            result = (down == MAT_WATER) ? MAT_WATER : MAT_EMPTY;
        }
        else 
        {
            int downLeft  = (id.y > 0 && id.x > 0) ? WorldIn[uint2(id.x - 1, id.y - 1)] : MAT_ROCK;
            int downRight = (id.y > 0 && id.x < _Width - 1) ? WorldIn[uint2(id.x + 1, id.y - 1)] : MAT_ROCK;

            bool tryLeft = parity;
            if (tryLeft && downLeft == MAT_EMPTY) result = MAT_EMPTY;
            else if (!tryLeft && downRight == MAT_EMPTY) result = MAT_EMPTY;
            else if (downLeft == MAT_EMPTY) result = MAT_EMPTY;
            else if (downRight == MAT_EMPTY) result = MAT_EMPTY;
        }
    }
    else if (self == MAT_WATER)
    {
        if (up == MAT_SAND) result = MAT_SAND;
        else if (down == MAT_EMPTY) result = MAT_EMPTY;
        else 
        {
            // 3. Sliding
            int downLeft  = (id.y > 0 && id.x > 0) ? WorldIn[uint2(id.x - 1, id.y - 1)] : MAT_ROCK;
            int downRight = (id.y > 0 && id.x < _Width - 1) ? WorldIn[uint2(id.x + 1, id.y - 1)] : MAT_ROCK;

            bool tryLeft = parity;
            bool slid = false;
            
            if (tryLeft && downLeft == MAT_EMPTY) { result = MAT_EMPTY; slid = true; }
            else if (!tryLeft && downRight == MAT_EMPTY) { result = MAT_EMPTY; slid = true; }
            else if (downLeft == MAT_EMPTY) { result = MAT_EMPTY; slid = true; }
            else if (downRight == MAT_EMPTY) { result = MAT_EMPTY; slid = true; }

            // 4. Horizontal Flow
            if (!slid)
            {
                // Use Parity to decide flow direction to prevent cloning/deletion conflicts
                // If Parity says LEFT, we try to move LEFT.
                // Receiver (Empty) at Left must also check Parity to know "Right is coming".
                
                if (parity)
                {
                    if (left == MAT_EMPTY) result = MAT_EMPTY;
                }
                else
                {
                    if (right == MAT_EMPTY) result = MAT_EMPTY;
                }
            }
        }
    }
    else if (self == MAT_EMPTY)
    {
        if (up == MAT_SAND) result = MAT_SAND;
        else if (up == MAT_WATER) result = MAT_WATER;
        else 
        {
             int upLeft = (id.y < _Height - 1 && id.x > 0) ? WorldIn[uint2(id.x - 1, id.y + 1)] : MAT_EMPTY;
             int upRight = (id.y < _Height - 1 && id.x < _Width - 1) ? WorldIn[uint2(id.x + 1, id.y + 1)] : MAT_EMPTY;
             
             bool sandL = (upLeft == MAT_SAND) && (left != MAT_EMPTY && left != MAT_WATER);
             bool sandR = (upRight == MAT_SAND) && (right != MAT_EMPTY && right != MAT_WATER);

             if (sandL && sandR) result = MAT_SAND;
             else if (sandL) result = MAT_SAND;
             else if (sandR) result = MAT_SAND;
             
             if (result == self)
             {
                 // Horizontal Water Flow Reception
                 // We must match the sender's logic exactly.
                 // Sender (Water) moves LEFT if parity is TRUE.
                 // So I (Empty) accept from RIGHT if parity is TRUE.
                 
                 if (parity)
                 {
                     if (right == MAT_WATER) result = MAT_WATER;
                 }
                 else
                 {
                     if (left == MAT_WATER) result = MAT_WATER;
                 }
                 
                 // Diagonal Water Slide Reception
                 // Water at UpLeft slides to DownRight (Me)
                 // Need to check if it actually wants to slide.
                 if (result == self)
                 {
                     int upL = (id.y < _Height - 1 && id.x > 0) ? WorldIn[uint2(id.x - 1, id.y + 1)] : MAT_EMPTY;
                     int upR = (id.y < _Height - 1 && id.x < _Width - 1) ? WorldIn[uint2(id.x + 1, id.y + 1)] : MAT_EMPTY;

                     // Simplified: If there is water above-diagonal, and it's blocked below, it comes here.
                     // This is "good enough" for V0 without complex parity checks,
                     // because sliding is destructive (downward) and less prone to infinite loops than horizontal.
                     
                     int leftVal = (id.x > 0) ? WorldIn[uint2(id.x-1, id.y)] : MAT_ROCK;
                     int rightVal = (id.x < _Width-1) ? WorldIn[uint2(id.x+1, id.y)] : MAT_ROCK;
                     
                     // Water at UpLeft checks Down (Left). If Blocked, it slides to DownRight (Me).
                     if (upL == MAT_WATER && leftVal != MAT_EMPTY) result = MAT_WATER;
                     else if (upR == MAT_WATER && rightVal != MAT_EMPTY) result = MAT_WATER;
                 }
             }
        }
    }

    WorldOut[id.xy] = result;
}
